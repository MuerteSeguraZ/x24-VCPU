#include "vcpu.cpp"

int main() {
    try {
        CPU cpu(65536, 8192, 256);

        int ram8_base = cpu.mem_size - cpu.ram8_size;

        vector<string> prog = {
            "PRINT \"[BOOT] CPU self-test starting...\"",
            "",
            "# --- Test NOP ---",
            "PRINT \"\\n=== Testing NOP ===\"",
            "",
            "PRINT \"Before NOP\"",
            "NOP",
            "NOP",
            "NOP",
            "PRINT \"After 3 NOPs (nothing should happen!)\"",
            "",
            "# NOP in a loop (delay simulation)",
            "LOADI 3 r8_0",
            "nop_loop:",
            "PRINT \"Loop iteration\"",
            "NOP",
            "NOP",
            "LOOP r8_0 nop_loop",
            "PRINT \"Loop done\"",
            "",
            "# --- Test Conditional Moves ---",
            "PRINT \"\\n=== Testing CMOV ===\"",
            "",
            "# CMOVE - Move if Equal (ZF=1)",
            "LOADI 10 r8_0",
            "LOADI 20 r8_1",
            "LCMP 5 5",               // Compare 5 with 5 -> ZF=1",
            "CMOVE r8_0 r8_1",        // Should move: r8_1 = r8_0",
            "PRINT \"CMOVE (ZF=1): r8_1=\"",
            "PRINT r8_1",             // Should be 10",
            "",
            "# CMOVNE - Move if Not Equal (ZF=0)",
            "LOADI 30 r8_2",
            "LOADI 40 r8_3",
            "LCMP 5 7",               // Compare 5 with 7 -> ZF=0",
            "CMOVNE r8_2 r8_3",       // Should move: r8_3 = r8_2",
            "PRINT \"CMOVNE (ZF=0): r8_3=\"",
            "PRINT r8_3",             // Should be 30",
            "",
            "# CMOVE when condition false",
            "LOADI 99 r8_4",
            "LOADI 50 r8_5",
            "LCMP 5 7",               // ZF=0",
            "CMOVE r8_4 r8_5",        // Should NOT move",
            "PRINT \"CMOVE (ZF=0, no move): r8_5=\"",
            "PRINT r8_5",             // Should still be 50",
            "",
            "# CMOVC - Move if Carry",
            "LOADI 100 r8_6",
            "LOADI 200 r8_7",
            "LUADD 100 r8_7",         // 200+100=300 (overflow) -> CF=1",
            "CMOVC 77 r8_6",          // Should move: r8_6 = 77",
            "PRINT \"CMOVC (CF=1): r8_6=\"",
            "PRINT r8_6",             // Should be 77",
            "",
            "# CMOVNC - Move if Not Carry",
            "LOADI 88 r16_0",
            "LOADI 5 r16_1",
            "CLC",                    // Clear carry",
            "CMOVNC r16_0 r16_1",     // Should move: r16_1 = 88",
            "PRINT \"CMOVNC (CF=0): r16_1=\"",
            "PRINT r16_1",            // Should be 88",
            "",
            "# CMOVS - Move if Sign (negative)",
            "LOADI 111 r8_8",
            "LOADI 200 r8_9",
            "LOADI 100 r8_10",
            "LCMP r8_9 r8_10",        // 100-200 = -100 -> SF=1",
            "CMOVS 222 r8_8",         // Should move: r8_8 = 222",
            "PRINT \"CMOVS (SF=1): r8_8=\"",
            "PRINT r8_8",             // Should be 222",
            "",
            "# CMOVNS - Move if Not Sign (positive)",
            "LOADI 123 r16_2",
            "LOADI 50 r8_11",
            "LCMP 50 r8_11",          // Compare 50 with r8_11 (50) -> ZF=1, SF=0",
            "CMOVNS 333 r16_2",       // Should move: r16_2 = 333",
            "PRINT \"CMOVNS (SF=0): r16_2=\"",
            "PRINT r16_2",            // Should be 333",
            "",
            "# --- Test JLE/JGE ---",
            "PRINT \"\\n=== Testing JLE/JGE ===\"",
            "",
            "# JLE - Jump if Less or Equal",
            "LOADI 5 r8_0",
            "LOADI 10 r8_1",
            "LCMP r8_0 r8_1",         // 10-5=5 (positive) -> SF=0, ZF=0",
            "JLE jle_error1",
            "PRINT \"JLE: Correctly didn't jump (5 < 10)\"",
            "JMP after_jle1",
            "jle_error1:",
            "PRINT \"JLE: ERROR - jumped when shouldn't\"",
            "after_jle1:",
            "",
            "# JLE with equal values",
            "LOADI 7 r8_2",
            "LOADI 7 r8_3",
            "LCMP r8_2 r8_3",         // 7-7=0 -> ZF=1",
            "JLE jle_equal",
            "PRINT \"JLE: ERROR - didn't jump on equal\"",
            "JMP after_jle2",
            "jle_equal:",
            "PRINT \"JLE: Correctly jumped (7 = 7)\"",
            "after_jle2:",
            "",
            "# JLE with less than",
            "LOADI 10 r8_4",
            "LOADI 5 r8_5",
            "LCMP r8_4 r8_5",         // 5-10=-5 (negative) -> SF=1",
            "JLE jle_less",
            "PRINT \"JLE: ERROR - didn't jump on less\"",
            "JMP after_jle3",
            "jle_less:",
            "PRINT \"JLE: Correctly jumped (10 > 5, so 5 <= 10)\"",
            "after_jle3:",
            "",
            "# JGE - Jump if Greater or Equal",
            "LOADI 10 r8_6",
            "LOADI 5 r8_7",
            "LCMP r8_6 r8_7",         // 5-10=-5 (negative) -> SF=1",
            "JGE jge_error1",
            "PRINT \"JGE: Correctly didn't jump (10 > 5)\"",
            "JMP after_jge1",
            "jge_error1:",
            "PRINT \"JGE: ERROR - jumped when shouldn't\"",
            "after_jge1:",
            "",
            "# JGE with equal values",
            "LOADI 9 r8_8",
            "LOADI 9 r8_9",
            "LCMP r8_8 r8_9",         // 9-9=0 -> ZF=1, SF=0",
            "JGE jge_equal",
            "PRINT \"JGE: ERROR - didn't jump on equal\"",
            "JMP after_jge2",
            "jge_equal:",
            "PRINT \"JGE: Correctly jumped (9 = 9)\"",
            "after_jge2:",
            "",
            "# JGE with greater than",
            "LOADI 5 r8_10",
            "LOADI 10 r8_11",
            "LCMP r8_10 r8_11",       // 10-5=5 (positive) -> SF=0",
            "JGE jge_greater",
            "PRINT \"JGE: ERROR - didn't jump on greater\"",
            "JMP after_jge3",
            "jge_greater:",
            "PRINT \"JGE: Correctly jumped (5 < 10, so 10 >= 5)\"",
            "after_jge3:",
            "",
            "# --- Test LEA (Load Effective Address) ---",
            "PRINT \"\\n=== Testing LEA ===\"",
            "",
            "# Simple address calculation",
            "LEA [100] r16_0",
            "PRINT r16_0",           // Should be 100
            "",
            "# Address with offset",
            "LEA [100+50] r16_1",
            "PRINT r16_1",           // Should be 150
            "",
            "# Using register as base",
            "LOADI 1000 r16_2",
            "LEA [r16_2+25] r16_3",
            "PRINT r16_3",           // Should be 1025
            "",
            "# Pointer arithmetic example",
            "LOADI 0xFF00 r16_4",   // Start of 8-bit RAM",
            "LOADI 10 r8_0",        // Offset",
            "LEA [r16_4+r8_0] r16_5",
            "PRINT r16_5",           // Should be 0xFF0A (65290)",
            "",
            "# Array indexing simulation",
            "LOADI 5000 r16_6",     // Array base",
            "LOADI 3 r8_1",         // Index",
            "LEA [r16_6+r8_1] r16_7",
            "PRINT r16_7",           // Should be 5003",
            "",
            "# --- Test XCHG (Exchange) ---",
            "PRINT \"\\n=== Testing XCHG ===\"",
            "",
            "# Exchange two 8-bit registers",
            "LOADI 10 r8_0",
            "LOADI 20 r8_1",
            "PRINT \"Before: r8_0=\"",
            "PRINT r8_0",
            "PRINT \"Before: r8_1=\"",
            "PRINT r8_1",
            "XCHG r8_0 r8_1",
            "PRINT \"After: r8_0=\"",
            "PRINT r8_0",
            "PRINT \"After: r8_1=\"",
            "PRINT r8_1",
            "",
            "# Exchange two 16-bit registers",
            "LOADI 1000 r16_8",
            "LOADI 2000 r16_9",
            "PRINT \"Before: r16_8=\"",
            "PRINT r16_8",
            "PRINT \"Before: r16_9=\"",
            "PRINT r16_9",
            "XCHG r16_8 r16_9",
            "PRINT \"After: r16_8=\"",
            "PRINT r16_8",
            "PRINT \"After: r16_9=\"",
            "PRINT r16_9",
            "",
            "# Exchange register with memory",
            "LOADI 99 r8_2",
            "LOADI " + to_string(ram8_base) + " r16_10",
            "LOADI 77 r8_3",
            "MOV r8_3 [r16_10]",  // Store 77 in memory
            "PRINT \"Before: r8_2=\"",
            "PRINT r8_2",
            "PRINT \"Before: mem=\"",
            "PRINT [r16_10]",
            "XCHG r8_2 [r16_10]",
            "PRINT \"After: r8_2=\"",
            "PRINT r8_2",
            "PRINT \"After: mem=\"",
            "PRINT [r16_10]",
            "",
            "# --- Test ROL/ROR (Rotate) ---",
            "PRINT \"\\n=== Testing ROL/ROR ===\"",
            "",
            "# ROL - Rotate Left",
            "LOADI 0xB2 r8_0",          // Hex: B2 = 178 = Binary: 10110010",
            "PRINT \"Before ROL: r8_0=\"",
            "PRINT r8_0",
            "ROL 1 r8_0",                // Rotate left by 1",
            "PRINT \"After ROL 1: r8_0=\"",
            "PRINT r8_0",                // Should be 101 (01100101)",
            "",
            "# ROL with wrapping",
            "LOADI 0xC0 r8_1",          // Hex: C0 = 192 = Binary: 11000000",
            "PRINT \"Before ROL: r8_1=\"",
            "PRINT r8_1",
            "ROL 2 r8_1",                // Rotate left by 2",
            "PRINT \"After ROL 2: r8_1=\"",
            "PRINT r8_1",                // Should be 3 (00000011)",
            "",
            "# ROR - Rotate Right",
            "LOADI 0xB2 r8_2",          // Hex: B2 = 178 = Binary: 10110010",
            "PRINT \"Before ROR: r8_2=\"",
            "PRINT r8_2",
            "ROR 1 r8_2",                // Rotate right by 1",
            "PRINT \"After ROR 1: r8_2=\"",
            "PRINT r8_2",                // Should be 89 (01011001)",
            "",
            "# ROR with wrapping",
            "LOADI 0x03 r8_3",          // Hex: 03 = 3 = Binary: 00000011",
            "PRINT \"Before ROR: r8_3=\"",
            "PRINT r8_3",
            "ROR 2 r8_3",                // Rotate right by 2",
            "PRINT \"After ROR 2: r8_3=\"",
            "PRINT r8_3",                // Should be 192 (11000000)",
            "",
            "# 16-bit rotation",
            "LOADI 0xFF00 r16_8",       // 1111111100000000",
            "PRINT \"Before ROL: r16_8=\"",
            "PRINT r16_8",
            "ROL 4 r16_8",               // Rotate left by 4",
            "PRINT \"After ROL 4: r16_8=\"",
            "PRINT r16_8",               // Should be 0xF00F (61455)",
            "",
            "# Variable rotation count",
            "LOADI 0xAA r8_4",          // AA = 170 = 10101010",
            "LOADI 3 r8_5",              // Count in register",
            "PRINT \"Before ROL: r8_4=\"",
            "PRINT r8_4",
            "ROL r8_5 r8_4",             // Rotate by r8_5 (3 times)",
            "PRINT \"After ROL 3: r8_4=\"",
            "PRINT r8_4",                // Should be 85 (01010101)",
            "",
            "# --- Test TEST (Bitwise AND for flags only) ---",
            "PRINT \"\\n=== Testing TEST ===\"",
            "",
            "# Test if a bit is set",
            "LOADI 0xAA r8_0",            // 170 = 10101010",
            "LOADI 0x02 r8_1",            // 2 = bit 1 mask",
            "TEST r8_1 r8_0",             // Check if bit 1 is set",
            "JZ bit_not_set",
            "PRINT \"Bit 1 is SET\"",
            "JMP after_bit_test",
            "bit_not_set:",
            "PRINT \"Bit 1 is NOT set\"",
            "after_bit_test:",
            "",
            "# Test if value is zero",
            "LOADI 0 r8_2",
            "TEST r8_2 r8_2",             // Test against itself",
            "JZ value_is_zero",
            "PRINT \"Value is NOT zero\"",
            "JMP after_zero_test",
            "value_is_zero:",
            "PRINT \"Value is zero!\"",
            "after_zero_test:",
            "",
            "# Test multiple bits",
            "LOADI 0xFF r8_3",            // All bits set",
            "LOADI 0x0F r8_4",            // Lower 4 bits mask",
            "TEST r8_4 r8_3",             // Check lower 4 bits",
            "JZ no_bits_set",
            "PRINT \"Some lower bits are set\"",
            "JMP after_multi_test",
            "no_bits_set:",
            "PRINT \"No bits set\"",
            "after_multi_test:",
            "",
            "# Test preserves operands",
            "LOADI 0xAB r8_5",
            "LOADI 0xCD r8_6",
            "PRINT \"Before TEST: r8_5=\"",
            "PRINT r8_5",
            "PRINT \"Before TEST: r8_6=\"",
            "PRINT r8_6",
            "TEST r8_5 r8_6",
            "PRINT \"After TEST: r8_5=\"",
            "PRINT r8_5",                 // Should still be 0xAB (171)",
            "PRINT \"After TEST: r8_6=\"",
            "PRINT r8_6",                 // Should still be 0xCD (205)",
            "",
            "# Test with 16-bit",
            "LOADI 0x8000 r16_10",        // Sign bit set",
            "TEST r16_10 r16_10",
            "JZ not_negative",
            "PRINT \"16-bit value has sign bit set\"",
            "JMP after_sign_test",
            "not_negative:",
            "PRINT \"16-bit value positive\"",
            "after_sign_test:",
            "",
            "# --- Test SAR (Arithmetic Shift Right) ---",
            "PRINT \"\\n=== Testing SAR ===\"",
            "",
            "# LSHR vs LSAR with positive number",
            "LOADI 64 r8_0",          // 01000000 (positive)",
            "LOADI 64 r8_1",
            "PRINT \"Positive value: 64\"",
            "LSHR 1 r8_0",            // Logical shift",
            "LSAR 1 r8_1",            // Arithmetic shift",
            "PRINT \"After LSHR 1: r8_0=\"",
            "PRINT r8_0",             // Should be 32",
            "PRINT \"After LSAR 1: r8_1=\"",
            "PRINT r8_1",             // Should be 32 (same for positive)",
            "",
            "# LSHR vs LSAR with negative number",
            "LOADI 192 r8_2",         // 11000000 (-64 in signed)",
            "LOADI 192 r8_3",
            "PRINT \"Negative value: 192 (= -64 signed)\"",
            "LSHR 1 r8_2",            // Logical shift -> fills with 0",
            "LSAR 1 r8_3",            // Arithmetic shift -> preserves sign",
            "PRINT \"After LSHR 1: r8_2=\"",
            "PRINT r8_2",             // Should be 96 (01100000)",
            "PRINT \"After LSAR 1: r8_3=\"",
            "PRINT r8_3",             // Should be 224 (11100000 = -32)",
            "",
            "# LSAR multiple shifts",
            "LOADI 128 r8_4",         // 10000000 (-128 in signed)",
            "PRINT \"Value: 128 (= -128 signed)\"",
            "LSAR 2 r8_4",            // Shift right by 2",
            "PRINT \"After LSAR 2: r8_4=\"",
            "PRINT r8_4",             // Should be 224 (11100000 = -32)",
            "",
            "# HSAR - 16-bit arithmetic shift",
            "LOADI 0x8000 r16_20",    // 1000000000000000 (-32768)",
            "PRINT \"16-bit negative: 32768 (= -32768 signed)\"",
            "HSAR 1 r16_20",
            "PRINT \"After HSAR 1: r16_20=\"",
            "PRINT r16_20",           // Should be 49152 (1100000000000000 = -16384)",
            "",
            "# HSAR on positive",
            "LOADI 16384 r16_21",     // 0100000000000000",
            "PRINT \"16-bit positive: 16384\"",
            "HSAR 2 r16_21",
            "PRINT \"After HSAR 2: r16_21=\"",
            "PRINT r16_21",           // Should be 4096",
            "",
            "# --- Test LOOP ---",
            "PRINT \"\\n=== Testing LOOP ===\"",
            "",
            "# Simple countdown with LOOP",
            "LOADI 5 r8_0",
            "PRINT \"Countdown from 5:\"",
            "countdown_loop:",
            "PRINT r8_0",
            "LOOP r8_0 countdown_loop",
            "PRINT \"Blastoff!\"",
            "",
            "# Print pattern 3 times",
            "LOADI 3 r8_1",
            "pattern_loop:",
            "PRINT \"*\"",
            "LOOP r8_1 pattern_loop",
            "",
            "# Nested loops - multiplication table 3x3",
            "LOADI 3 r8_2",           // Outer counter",
            "outer_loop:",
            "LOADI 3 r8_3",           // Inner counter",
            "inner_loop:",
            "PRINT \".\"",
            "LOOP r8_3 inner_loop",
            "PRINT \"\\n\"",
            "LOOP r8_2 outer_loop",
            "",
            "# 16-bit loop",
            "LOADI 3 r16_11",
            "PRINT \"16-bit loop:\"",
            "loop16:",
            "PRINT r16_11",
            "LOOP r16_11 loop16",
            "PRINT \"16-bit done!\"",
            "",
"# --- Test BT/BTS/BTR/BTC ---",
            "PRINT \"\\n=== Testing Bit Operations ===\"",
            "",
            "# BT - Bit Test",
            "LOADI 0xAA r8_0",        // 170 = 10101010",
            "BT 1 r8_0",              // Test bit 1 (should be 1)",
            "JC bit1_set",
            "PRINT \"Bit 1 NOT set (ERROR)\"",
            "JMP after_bt1",
            "bit1_set:",
            "PRINT \"BT: Bit 1 is set\"",
            "after_bt1:",
            "",
            "BT 2 r8_0",              // Test bit 2 (should be 0)",
            "JC bit2_error",
            "PRINT \"BT: Bit 2 is clear\"",
            "JMP after_bt2",
            "bit2_error:",
            "PRINT \"Bit 2 set (ERROR)\"",
            "after_bt2:",
            "",
            "# BTS - Bit Test and Set",
            "LOADI 0 r8_1",
            "PRINT \"Before BTS: r8_1=\"",
            "PRINT r8_1",
            "BTS 3 r8_1",             // Set bit 3",
            "PRINT \"After BTS 3: r8_1=\"",
            "PRINT r8_1",             // Should be 8 (0b00001000)",
            "",
            "# BTR - Bit Test and Reset",
            "LOADI 0xFF r8_2",        // All bits set",
            "PRINT \"Before BTR: r8_2=\"",
            "PRINT r8_2",
            "BTR 7 r8_2",             // Clear bit 7",
            "PRINT \"After BTR 7: r8_2=\"",
            "PRINT r8_2",             // Should be 127 (0b01111111)",
            "",
            "# BTC - Bit Test and Complement",
            "LOADI 0xAA r8_3",        // 170 = 10101010",
            "PRINT \"Before BTC: r8_3=\"",
            "PRINT r8_3",
            "BTC 0 r8_3",             // Flip bit 0",
            "PRINT \"After BTC 0: r8_3=\"",
            "PRINT r8_3",             // Should be 171 (0b10101011)",
            "",
            "# --- Test MOVZX/MOVSX ---",
            "PRINT \"\\n=== Testing MOVZX/MOVSX ===\"",
            "",
            "# MOVZX - Zero extend positive",
            "LOADI 0x7F r8_4",        // 127 (positive)",
            "MOVZX r8_4 r16_12",
            "PRINT \"MOVZX 127: r16_12=\"",
            "PRINT r16_12",           // Should be 127",
            "",
            "# MOVZX - Zero extend 'negative' as unsigned",
            "LOADI 0xFF r8_5",        // 255 (or -1 if signed)",
            "MOVZX r8_5 r16_13",
            "PRINT \"MOVZX 255: r16_13=\"",
            "PRINT r16_13",           // Should be 255",
            "",
            "# MOVSX - Sign extend positive",
            "LOADI 0x7F r8_6",        // 127 (positive)",
            "MOVSX r8_6 r16_14",
            "PRINT \"MOVSX 127: r16_14=\"",
            "PRINT r16_14",           // Should be 127",
            "",
            "# MOVSX - Sign extend negative",
            "LOADI 0xFF r8_7",        // -1 in signed 8-bit",
            "MOVSX r8_7 r16_15",
            "PRINT \"MOVSX -1: r16_15=\"",
            "PRINT r16_15",           // Should be 65535 (0xFFFF = -1 in 16-bit)",
            "",
            "# --- Test MOV instruction ---",
            "PRINT \"\\n=== Testing MOV ===\"",
            "LOADI 42 r8_0",
            "MOV r8_0 r8_1",
            "PRINT r8_0",
            "PRINT r8_1",
            "",
            "# --- Test LOADI ---",
            "PRINT \"\\n=== Testing LOADI ===\"",
            "LOADI 100 r8_2",
            "LOADI 5000 r16_0",
            "PRINT r8_2",
            "PRINT r16_0",
            "",
            "# --- Test Carry Flag with overflow ---",
            "PRINT \"\\n=== Testing Carry Flag ===\"",
            "LOADI 255 r8_3",
            "LOADI 1 r8_4",
            "LUADD r8_4 r8_3",
            "PRINT r8_3",
            "SALC",
            "PRINT r8_0",
            "",
            "# --- Test JC (Jump if Carry) ---",
            "PRINT \"\\n=== Testing JC ===\"",
            "LOADI 200 r8_5",
            "LOADI 100 r8_6",
            "LUADD r8_6 r8_5",
            "JC carry_set",
            "PRINT \"Carry NOT set (ERROR!)\"",
            "JMP after_carry",
            "carry_set:",
            "PRINT \"Carry flag is set!\"",
            "after_carry:",
            "",
            "# --- Test CLC and STC ---",
            "PRINT \"\\n=== Testing CLC/STC ===\"",
            "STC",
            "SALC",
            "PRINT r8_0",
            "CLC",
            "SALC",
            "PRINT r8_0",
            "",
            "# --- Test CMC ---",
            "PRINT \"\\n=== Testing CMC ===\"",
            "CLC",
            "CMC",
            "SALC",
            "PRINT r8_0",
            "",
            "# --- Original tests ---",
            "PRINT \"\\n=== Original Tests ===\"",
            "LPUT 10 r8_10",
            "LPUT 20 r8_11",
            "LUADD r8_10 r8_11",
            "PRINT r8_11",
            "",
            "LWSB r8_11 [" + to_string(ram8_base) + "]",
            "LREAD [" + to_string(ram8_base) + "] r8_12",
            "PRINT r8_12",
            "",
            "HPUT 5000 r16_1",
            "HPUT 2345 r16_2",
            "HUADD r16_1 r16_2",
            "PRINT r16_2",
            "",
            "DUMP REGS",
            "",
            "PRINT \"\\n[BOOT] All tests completed successfully!\"",
            "QUIT"
        };

        cpu.load_program_lines(prog);
        cpu.run();

        cout << "\n=== Memory Dump ===\n";
        cout << "Dumping 8-bit RAM region:\n";
        for (int i = 0; i < min(64, (int)cpu.ram8_size); i++) {
            if (i % 16 == 0) cout << hex << setw(4) << setfill('0') << (ram8_base + i) << ": ";
            cout << hex << setw(2) << setfill('0') << (int)cpu.mem[ram8_base + i] << " ";
            if (i % 16 == 15) cout << "\n";
        }
        cout << dec << "\n";

    } catch (const exception &ex) {
        cerr << "Runtime error: " << ex.what() << "\n";
        return 2;
    }
    return 0;
}