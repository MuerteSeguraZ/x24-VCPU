#include <iostream>
#include <vector>
#include <string>
#include "vcpu.cpp"

using namespace std;

int main() {
    try {
        CPU cpu;
        
    vector<string> mmu_test = {
    "# MMU and Virtual Memory Test",
    "",
    "# Allocate page directory at physical address 0x1000 (page 16)",
    "HPUT 0x1000 r16_0",
    "",
    "# Setup identity mapping for first 16 pages (kernel space)",
    "# Virtual pages 0-15 -> Physical pages 0-15",
    "HPUT 0 r16_1",  // Counter
    "setup_kernel:",
    "    MAPPG r16_1 r16_1 0x03  # Present, writable, supervisor (not user)",
    "    HUADD 1 r16_1",
    "    HCMP 16 r16_1",
    "    JL setup_kernel",
    "",
    "PRINT \"Kernel pages mapped (identity)\"",
    "",
    "# Enable paging with kernel page directory FIRST",
    "ENABLEPAGING 0x1000",
    "",
    "# Now create processes (this will work because we have identity mapping)",
    "CREATEPROC 1 Process_A",
    "CREATEPROC 2 Process_B",
    "",
    "# Setup Process A's address space",
    "SWITCHPROC 1",
    "",
    "# First, setup identity mapping for kernel in Process A too",
    "HPUT 0 r16_1",
    "setup_kernel_a:",
    "    MAPPG r16_1 r16_1 0x03  # Kernel pages",
    "    HUADD 1 r16_1",
    "    HCMP 16 r16_1",
    "    JL setup_kernel_a",
    "",
    "# Map virtual page 100 to physical page 20",
    "MAPPG 100 20 0x07  # Present, writable, user",
    "# Map virtual page 101 to physical page 21",  
    "MAPPG 101 21 0x07",
    "PRINT \"Process A address space configured\"",
    "",
    "# Setup Process B's address space",
    "SWITCHPROC 2",
    "",
    "# Setup identity mapping for kernel in Process B too",
    "HPUT 0 r16_1",
    "setup_kernel_b:",
    "    MAPPG r16_1 r16_1 0x03  # Kernel pages",
    "    HUADD 1 r16_1",
    "    HCMP 16 r16_1",
    "    JL setup_kernel_b",
    "",
    "# Map virtual page 100 to physical page 30 (different!)",
    "MAPPG 100 30 0x07  # Present, writable, user",
    "# Map virtual page 101 to physical page 31",
    "MAPPG 101 31 0x07",
    "PRINT \"Process B address space configured\"",
    "",
    "# Test Process A",
    "SWITCHPROC 1",
    "PRINT \"Testing Process A isolation...\"",
    "",
    "# Write to virtual address 0x6400 (page 100, offset 0)",
    "HPUT 0x6400 r16_2",
    "LPUT 0xAA r8_0",
    "STORE r8_0 r16_2",
    "PRINT \"Process A wrote 0xAA to virtual 0x6400\"",
    "",
    "# Read it back",
    "HREAD [r16_2] r16_4",
    "PRINT \"Process A read back:\"",
    "PRINT r16_4",
    "",
    "# Switch to Process B",
    "SWITCHPROC 2",
    "PRINT \"Testing Process B isolation...\"",
    "",
    "# Write different value to same virtual address",
    "HPUT 0x6400 r16_2",
    "LPUT 0xBB r8_0",
    "STORE r8_0 r16_2",
    "PRINT \"Process B wrote 0xBB to virtual 0x6400\"",
    "",
    "# Read it back",
    "HREAD [r16_2] r16_4",
    "PRINT \"Process B read back:\"",
    "PRINT r16_4",
    "",
    "# Switch back to Process A",
    "SWITCHPROC 1",
    "PRINT \"Verifying Process A still has its data...\"",
    "HPUT 0x6400 r16_2",
    "HREAD [r16_2] r16_4",
    "PRINT \"Process A still has:\"",
    "PRINT r16_4",
    "",
    "# Verify it's 0xAA (170 in decimal)",
    "HPUT 0xAA r16_3",
    "HCMP r16_3 r16_4",
    "JE isolation_success",
    "PRINT \"ERROR: Process isolation failed!\"",
    "JMP test_readonly",
    "",
    "isolation_success:",
    "PRINT \"SUCCESS: Processes are properly isolated!\"",
    "",
    "test_readonly:",
    "PRINT \"\"",
    "PRINT \"Testing read-only protection...\"",
    "MAPPG 102 40 0x05  # Present, read-only, user",
    "",
    "# Write a value we can read",
    "# First, temporarily make it writable",
    "MAPPG 102 40 0x07",
    "HPUT 0x6600 r16_3",
    "LPUT 0xCC r8_0",
    "STORE r8_0 r16_3",
    "PRINT \"Wrote 0xCC to page 102\"",
    "",
    "# Now make it read-only",
    "MAPPG 102 40 0x05",
    "INVLPG 0x6600",
    "",
    "# Read should work",
    "HREAD [r16_3] r16_5",
    "PRINT \"Read from read-only page:\"",
    "PRINT r16_5",
    "",
    "# Try to write (should fail - we'll skip this)",
    "# LPUT 0xDD r8_0",
    "# STORE r8_0 r16_3  # This would cause page fault",
    "",
    "PRINT \"Read-only test complete (write test skipped to avoid fault)\"",
    "",
    "DISABLEPAGING",
    "PRINT \"\"",
    "PRINT \"=== Virtual memory test complete ===\"",
    "QUIT",
};
        cpu.load_program_lines(mmu_test);
        cpu.run();
        
        cout << "\n=== Test completed successfully! ===\n";
        
    } catch (const exception& e) {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    
    return 0;
}